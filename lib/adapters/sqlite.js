'use strict';

require('babel-polyfill');

const _ = require('lodash'),
  Promise = require('bluebird'),
  sprintf = require('sprintf-js').sprintf,
  sqlite = require('sqlite/legacy');

const DEBUG = process.env.DEBUG;

function isInsertOrUpdate(query) {
  return _.startsWith(query, 'INSERT') ||
    _.startsWith(query, 'UPDATE');
}

// TODO: move to initialization
// e.g.:
//   const adelia = require('adelia')(CONFIG);
//   const model = new adelia.Model();
const CONFIG = {
  database: process.env.SQLITE_DB
};

function SQLiteAdapter() {
}

_.assign(SQLiteAdapter.prototype, {
  /**
   *  @attr NAME
   *  @short Name of this adapter
   */
  NAME: 'sqlite',

  /**
   *  @attr queries_count
   *  @short Counter for queries executed.
   */
  queries_count: 0,

  /**
   *  @attr connection
   *  @short Connection link to the database.
   */
  connection: null,

  /**
   *  @attr query
   *  @short Query for the database.
   */
  query: null,

  /**
   *  @attr result
   *  @short The result of the last query.
   */
  result: null,

  /**
   *  @fn connect
   *  @short Connects to the database.
   */
  connect: function(database) {
    if (_.isUndefined(this.connection) || this.connection === null) {
      const db = _.defaultTo(database, CONFIG.database);

      this.connection = sqlite.open(db);
    }

    return this.connection;
  },

  /**
   *  @fn select_db(database_name)
   *  @short Selects the desired database.
   *  @param database_name The name of the database.
   */
  // select_db: function(database_name) {
  //   this.connect();
  //   return mysql_select_db(database_name, this.link);
  // },

  /**
   *  @fn close
   *  @short Closes the connection to the database.
   */
  close: function() {
    // TODO:
  },

  /**
   *  @fn prepare(query)
   *  @short Prepares a query for execution
   *  @param query The query to execute.
   */
  prepare: function(query) {
    this.connect();

    let args = arguments;
    let args_len = arguments.length;
    if (args_len > 1) {
      for (let i = 1; i < args_len; i++) {
        // query = query.replace('{' + i + '}', mysql.escape(args[i]));
        query = query.replace('{' + i + '}', args[i]);
      }
    }
    this.query = query;

    if (DEBUG) {
      this._printQuery();
    }
  },

  /**
   *  @fn exec
   *  @short Executes a query.
   */
  exec: function() {
    const self = this;

    return this.connect()
      .then(function() {
        if (isInsertOrUpdate(self.query)) {
          self.result = sqlite.run(self.query)
            .then(function(result) {
              if (!_.isUndefined(result.lastID) && result.lastID !== 0) {
                result.insertId = result.lastID;
              }
              return result;
            });
        } else {
          self.result = sqlite.all(self.query);
        }
        self.queries_count++;

        return self.result;
      });
  },

  /**
   *  @fn getColumns
   *  @short Describes a table.
   */
  getColumns: function(tableName) {
    const CONSTRAINT_KEYWORDS = ['CONSTRAINT', 'PRIMARY', 'UNIQUE', 'CHECK', 'FOREIGN'];

    return this.connect()
      .then(function() {
        return sqlite.get(sprintf("SELECT sql FROM sqlite_master WHERE name = '%s'", tableName));
      })
      .then(function(result) {
        const sql = result.sql;
        const matches = sql.match(/\(([^]+)\)/m);
        let columns = [];

        if (matches) {
          columns = matches[1]
            .replace(/\([^)]+\)/m, '')
            .split(',')
            .map(function(el) {
              return el
                .trim()
                .split(' ')[0]
                .replace(/["']/g, '')
            })
            .filter(function(el) {
              return !_.includes(CONSTRAINT_KEYWORDS, el);
            });
        }

        return Promise.resolve(columns);
      });
  },

  /**
   *  @fn insert_id
   *  @short Returns the id generated by the last INSERT query.
   */
  insert_id: function() {
    return mysql_insert_id(this.link);
  },

  /**
   *  @fn escape(value)
   *  @short Escapes the given value to avoid SQL injections.
   *  @param value The value to escape.
   */
  escape: function(value) {
    this.connect();
    return mysql.escape(value, this.link);
  },


  /**
   *  @fn result(pos, colname)
   *  @short Returns a single result of the last SELECT query.
   *  @param row The row of the resultset.
   *  @param colname The name (or the alias, if applicable) of the desired row.
   */
  result: function(pos, colname) {
    pos = pos || 0;

    if (colname === undefined) {
      colname = null;
    }

    return mysql_result(this.result, pos, colname);
  },

  /**
   *  @fn num_rows
   *  @short Returns the number of rows returned by a previous SELECT query.
   */
  num_rows: function() {
    return mysql_num_rows(this.result);
  },

  /**
   *  @fn affected_rows
   *  @short Returns the number of rows affected by a previous INSERT, UPDATE or DELETE query.
   */
  affected_rows: function() {
    return mysql_affected_rows(this.result);
  },

  /**
   *  @fn fetch_assoc
   *  @short Returns the current row of the resultset as an associative array.
   */
  fetch_assoc: function() {
    return mysql_fetch_assoc(this.result);
  },

  /**
   *  @fn fetch_array
   *  @short Returns the current row of the resultset as an array.
   */
  fetch_array: function() {
    return mysql_fetch_array(this.result);
  },

  /**
   *  @fn free_result
   *  @short Releases the result of the last query.
   */
  free_result: function() {
    mysql_free_result(this.result);
  },

  /**
   *  @fn _printQuery
   *  @short Prints the query to the console.
   */
  _printQuery: function() {
    console.log(this.query);
  }
});

module.exports = SQLiteAdapter;
